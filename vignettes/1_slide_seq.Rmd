---
title: "slide_seq"
author: "Brendan F. Miller"
date: "12/23/2022"
output: html_document
---

# RCTD/spacexr data

Use the preprocessed data of the Cerebellum provided by the RCTD/spacexr papers

Mainly focusing on the cell type annotations in Figure 4:
https://raw.githack.com/dmcable/spacexr/master/AnalysisPaper/MainFigures/figure4.html

Unfortunately, the `RCTD` package has been renamed to `spacexr`, and this causes some issues loading in objects that were created by the original `RCTD`.

For example, in the provided markdown code to generate figure 4, the `puck` object cannot be loaded because it was an output of `RCTD`. But this is ok because the relevant information can still be collected.

Data:
https://www.dropbox.com/sh/6klgiz1f9rimzqb/AAB1fYQt7yovcUzm5EnO8HVba/190926_08_share?dl=0&subfolder_nav_tracking=1

We want:
- `puckCropped.rds`; which is the coordinates of the beads with >=100 UMIs (already filtered in the analysis)
  - the same object is also available here: https://www.dropbox.com/sh/6klgiz1f9rimzqb/AADX_ziLibO7XY5S4rwPLdQoa/Figure4?dl=0&subfolder_nav_tracking=1
- `gathered_results.RData`; contains the `results` object, which contains the cell type predictions from RCTD in `$results_df`


```{r}

puckCropped <- readRDS("/Users/brendan/Desktop/PostDoc/work/HuBMAP/data/slide_seq/cerebellum_puckCropped_spacexr.rds")

```

```{r}

plot(puckCropped@coords$x, puckCropped@coords$y, cex = 0.1)

```

```{r}

load("/Users/brendan/Desktop/PostDoc/work/HuBMAP/data/slide_seq/gathered_results.RData")

```

```{r}

puck <- puckCropped@coords

```

check to make sure the same bead barcodes used for the filtered puck coordinates and the RCTD results

```{r}

length(rownames(puck))
length(rownames(results$results_df))
length(intersect(rownames(puck), rownames(results$results_df)))

```

make the dataframe with filtered beads and primary cell type assignment

```{r}

## remove beads that were rejected by rctd
barcodes1 <- rownames(results$results_df[results$results_df$spot_class != "reject",])
## barcodes with more than 100 UMIs
barcodes2 <- rownames(puckCropped@coords)
barcodes2 <- barcodes2[which(puckCropped@nUMI >= 100)]

barcodes <- intersect(barcodes1, barcodes2)

results_table <- puckCropped@coords[barcodes,]

## add in predicted cell classes from rctd
results_table$class <- factor(results$results_df[barcodes, "first_type"])

```

## visualize cell types

try the plotting from the rctd figure 4 markdown

```{r}

n_levels <- iv$cell_type_info[[3]]
my_pal <- pals::kelly(n_levels+1)[2:(n_levels+1)]
my_pal_curr <- my_pal
my_pal_curr["Oligodendrocytes"] <- "#CC79A7"
my_pal_curr["MLI1"] <- "#E69F00"
my_pal_curr["Astrocytes"] <- "#56B4E9"
my_pal_curr["Granule"] <- "#009E73"
my_pal_curr["MLI2"] <- "#F0E442"
my_pal_curr["Bergmann"] <- "#0072B2"
my_pal_curr["Purkinje"] <- "#D55E00"
my_pal_curr["Golgi"] <- "#000000"
my_pal_curr["Endothelial"] <- my_pal["Oligodendrocytes"]
my_pal_curr["Ependymal"] <- my_pal["Purkinje"]
my_pal_curr["Lugaro"] <- my_pal["MLI2"]
pres <- unique(as.integer(results_table$class))
pres <- pres[order(pres)]

ggplot2::ggplot(results_table, ggplot2::aes(x=x, y=y)) +
  ggplot2::geom_point(ggplot2::aes(size = .1, shape=19, color=class)) +
  ggplot2::scale_color_manual(values = my_pal_curr[pres],
                              breaks = c('Astrocytes','Bergmann','Granule','Purkinje','MLI2','Oligodendrocytes','MLI1'),
                              labels = c('Astrocytes','Bergmann','Granule','Purkinje','MLI2','Oligo','MLI1')) +
  ggplot2::scale_shape_identity() +
  ggplot2::theme_classic() +
  ggplot2::scale_size_identity() +
  ggplot2::coord_fixed() +
  ggplot2::theme(legend.position = "top") +
  ggplot2::guides(colour = guide_legend(override.aes = list(size=2))) +
  ggplot2::scale_x_continuous(breaks = c(1000,3000,5000), limits = c(900,5600)) +
  ggplot2::scale_y_continuous(breaks = c(1000,3000,5000), limits = c(1000,4900)) +
  ggplot2::geom_segment(aes(x = 1300, y = 1700, xend = 1684.6, yend = 1700), color = "black") +
  ggplot2::theme(axis.title.x = ggplot2::element_blank(),
                 axis.text.x = ggplot2::element_blank(),
                 axis.ticks.x = ggplot2::element_blank(),
                 axis.title.y = ggplot2::element_blank(),
                 axis.text.y = ggplot2::element_blank(),
                 axis.ticks.y = ggplot2::element_blank())

```

black scale bar is 250um according to the original paper fyi. For multiscale, probably could use neighbor and subset distance of 100?

legend coloring isn't working. Don't really care about spending time to figure it out.

let's try my functions instead:

```{r, fig.height=12, fig.width=12}

vizAllClusters(object = results_table[,c("x", "y")], clusters = results_table$class, s = 2)

```

```{r, fig.height=18, fig.width=18}

vizEachCluster(object = results_table[,c("x", "y")], clusters = results_table$class, s = 2)

```

```{r}

table(results_table$class)

```

let's reduce down some of the cell types that aren't really present at meaningful levels

```{r}

results_table_filt <- results_table[!results_table$class %in% c("Candelabrum", "Choroid", "Ependymal", "Globular", "Macrophages"),]
results_table_filt$class <- droplevels(results_table_filt$class)

```

## save object to process on rockfish

```{r}

write.csv2(x = results_table_filt, file = "/Users/brendan/Desktop/PostDoc/work/HuBMAP/repos/multiscale_celltype_colocalization_analysis/data/temp/slideseqPuck.190926_08.rctd.meta.csv", row.names = TRUE)

```

## check functions and output

```{r}

meta <- read.csv2(file = "/Users/brendan/Desktop/PostDoc/work/HuBMAP/repos/multiscale_celltype_colocalization_analysis/data/temp/slideseqPuck.190926_08.rctd.meta.csv.gz", row.names = 1)

## name of column with cell type annotations to use
## for example, "celltypes", or "celltypes_folBcombined"
meta <- meta[,c("x", "y", as.character("class"))]

cells <- sp::SpatialPointsDataFrame(
  coords = as.data.frame(pos),
  data=data.frame(
    celltypes=celltypes
    #name=rownames(pos)
))
cells <- sf::st_as_sf(cells)

## Change rowname assignments of cells to integers.
## Solution to keep rows in same order later on when
## randomly shuffling cell labels
rownames(cells) <- as.character(1:dim(cells)[1])

# make asumption that cell type attribute is constant throughout the geometries of each cell
## it removed the warning that keep popping up, which says this assumption is made anyways
sf::st_agr(cells) <- "constant"

```

```{r}

resolutions <- c(50, 100, 200, 300, 500, 600, 700, 800, 900, 1000, 1200, 1500, 3000)

randomcellslist <- makeShuffledCells(cells,
                                     resolutions,
                                     perms = 1,
                                     ncores = 7,
                                     seed = 1,
                                     verbose = TRUE)

```

```{r}

subset.list <- getSubsets(cells = cells,
                          sub.dist = 100,
                          sub.type = "near",
                          sub.thresh = 0.05,
                          ncores = 7,
                          verbose = TRUE)

```

```{r}

cells
randomcellslist
subset.list

```

```{r}

combo_ids <- names(subset.list)
d <- 100

```


Run the analysis using the scripts on rockfish...

dist=100, subdist=100
dist=100, subdist=200
dist=200, subdist=200


## analysis of the results

```{r}

dataDir <- "/Users/brendan/Desktop/PostDoc/work/HuBMAP/repos/multiscale_celltype_colocalization_analysis/data/temp/results/triplet/"
figpath <- "/Users/brendan/Desktop/PostDoc/work/HuBMAP/repos/multiscale_celltype_colocalization_analysis/plots/slideseq/"

```

```{r}

outfile <- paste0(dataDir, "slideseqPuck.190926_08.rctd.near.binom.subdist100.dist100.results.rds")
dat <- readRDS(outfile)

dat <- meltResultsList(resultsList = dat, id = 100)
colnames(dat) <- c("resolution", "neighbor", "Z", "reference", "dist", "subsetDist")

dat <- dat[dat$resolution %in% c(50,100,200,600,700,800,1000,3000),]

dat <- dat[grepl(pattern = "Purkinje_near_", x = dat$reference),]

plotTrends(results = dat, idcol = "dist", figPath = paste0(figpath, "slideseqPuck.190926_08_dist100_subDist100.subsets.purk.pdf"),
          width = 30, height = 30)

```

```{r}

outfile <- paste0(dataDir, "slideseqPuck.190926_08.rctd.near.binom.subdist100.dist100.results.rds")
dat <- readRDS(outfile)

dat <- meltResultsList(resultsList = dat, id = 100)
colnames(dat) <- c("resolution", "neighbor", "Z", "reference", "dist", "subsetDist")

dat <- dat[dat$resolution %in% c(50,100,200,600,700,800,1000,3000),]

dat <- dat[grepl(pattern = "Bergmann_near_", x = dat$reference),]

plotTrends(results = dat, idcol = "dist", figPath = paste0(figpath, "slideseqPuck.190926_08_dist100_subDist100.subsets.berg.pdf"),
          width = 30, height = 30)

```

```{r}

outfile <- paste0(dataDir, "slideseqPuck.190926_08.rctd.near.binom.subdist100.dist100.results.rds")
dat <- readRDS(outfile)

dat <- meltResultsList(resultsList = dat, id = 100)
colnames(dat) <- c("resolution", "neighbor", "Z", "reference", "dist", "subsetDist")

dat <- dat[dat$resolution %in% c(50,100,200,600,700,800,1000,3000),]

dat <- dat[grepl(pattern = "Granule_near_", x = dat$reference),]

plotTrends(results = dat, idcol = "dist", figPath = paste0(figpath, "slideseqPuck.190926_08_dist100_subDist100.subsets.gran.pdf"),
          width = 30, height = 30)

```

# Use the STdeconvolve results

load from:

```{r}

load("/Users/brendan/Desktop/PostDoc/work/STDeconvolve/vignettes/1_purkinje/20210929.purkinje.Image.RData")

```

interested in: 
- `cerebellumCorpus`; the positions
- `rctd_cerebellum_theta`; RCTD results (this was v1.2.0), using full mode and converting the probabilities to proportions,

take the cell type with the highest probabilitiy for each bead

can do the same thing for the STdeconvolve theta results as well.

I also filtered for beads that were deconvolved for RTCD and STdeconvolve. 

Note that this is a different puck/slide seq sample than what was shown in the RCTD paper. So the sample slice looks different. Might be a way to double check results using the RCTD dataset above?

Can look for consistencies between each biological replicate?

```{r}

#' Function to reduce theta matrices down to the top X cell-types in each
#' pixel. 
#' 
#' @description The cell-types with the top X highest proportions are kept in each
#'     pixel and the rest are set to 0. Then renormalizes the pixel proportions to sum to 1.
#'     Cell-types that result in 0 in all pixels after this filtering step are removed.
#'
#' @param theta pixel (rows) by cell-types (columns) distribution matrix. Each row
#'     is the cell-type composition for a given pixel
#' @param top Select number of top cell-types in each pixel to keep (default: 3)
#' 
#' @return A filtered pixel (rows) by cell-types (columns) distribution matrix.
#' 
#' @noRd
reduceTheta <- function(theta, top=3){
  
  theta_filt <- do.call(rbind, lapply(seq(nrow(theta)), function(i){
    p <- theta[i,]
    thresh <- sort(p, decreasing=TRUE)[top]
    p[p < thresh] <- 0
    p
  }))
  
  colnames(theta_filt) <- colnames(theta)
  rownames(theta_filt) <- rownames(theta)
  
  theta_filt <- theta_filt/rowSums(theta_filt)
  ## if NAs because all cts are 0 in a spot, replace with 0
  theta_filt[is.na(theta_filt)] <- 0
  ## drop any cts that are 0 for all pixels
  theta_filt <- theta_filt[,which(colSums(theta_filt) > 0)]
  
  return(theta_filt)
}

```

```{r}

p <- cerebellumCorpus$pos
t <- rctd_cerebellum_theta
colnames(t) <- cb_cell_dict$common_name
t <- reduceTheta(theta = t, top = 1)

```

```{r}

com <- as.factor(colnames(t)[t %*% 1:ncol(t)])
names(com) <- rownames(t)

```

```{r, fig.height=15, fig.width=15}

vizAllClusters(object = p[rownames(t),], clusters = com, s = 2)

```

```{r, fig.height=15, fig.width=15}

vizAllClusters(object = p[rownames(t),], clusters = com, ofInterest = c("Bergmann Glia", "Purkinje Neurons"),
               s = 2)

```



