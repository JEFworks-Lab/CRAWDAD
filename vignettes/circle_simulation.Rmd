# ---
title: "Simulation"
output: rmarkdown::html_vignette
vignette: >
  %\VignetteIndexEntry{circle_simulation}
  %\VignetteEngine{knitr::rmarkdown}
  %\VignetteEncoding{UTF-8}
---

```{r, include = FALSE}
knitr::opts_chunk$set(
  collapse = TRUE,
  comment = "#>"
)
```

```{r setup}
library(msctcla)
```

# Simulation

This vignette shows how to use our package to identify cell-type co-localization patterns. In this case, we use simulated circular pattern as the data.

## Simulate the data

We will make a single circle, but you can make several different simulations by changing the number of circles, the size of the ring and the inner core.

```{r}
## background parameters
scale <- 1000 # can be interpreted as microns
size <- 1000 # number of cells
cell_type_background <- c("A")
probability_background <- c(1)

## create background
background_data <- simulate_background(size = size, 
                                       cts = cell_type_background, 
                                       prob = probability_background,
                                       scale = scale)

## circle parameters
circle_centers <- list(c(500, 500)) # on the chosen scale
cell_types <- list(list(outer = "B", inner = c("C")))
probabilities <- list(list(outer = c(1), inner = c(1)))

## inner circle of 100 microns and outer of 150 microns
radii_150 <- list(list(outer = 150, inner = 100))

## create simulated data with pattern
simulated_data_150 <- simulate_circles(background_data,
                                      circle_centers, 
                                      radii_150, 
                                      cell_types, 
                                      probabilities)

simulated_data_150$id <- 150 # to identify the circle with 150 microns width

## in case there ere multiple circles of different sizes, you would need to add
## them to this list
circle_patterns <- dplyr::bind_rows(list(
  simulated_data_150
))
circle_patterns$id <- factor(circle_patterns$id, ordered = TRUE, 
                             levels = c("150"))
```

Visualize the data.

```{r}
ggplot2::ggplot(data = simulated_data_150) +
  ggplot2::geom_point(ggplot2::aes(x = x, y = y, color = type)) +
  ggplot2::scale_color_discrete() 
```

## find trends

```{r}
d <- 100 # each distance to define neighbors when computing trends
resolutions <- c(50, 100, 200, 300) # different shuffling resolutions to try
prms <- 1 # number of permutations for shuffling; I found that there isn't much variance so 1 is ok for now
sd <- 1 # the seed for shuffling
ncs <- 7 # number of cores for parallelization. My machine has 8 total so I use 7

positions <- simulated_data_150
results_circsize150 <- findTrendsv2(pos = positions[,c("x", "y")],
                                   celltypes = positions$type,
                                   resolutions,
                                   dist = d,
                                   perms = prms,
                                   ncores = ncs,
                                   verbose = TRUE,
                                   saveShuffleFile = 'test.rds',
                                   seed = sd)



## melt this higher order dataframe list of dataframes into a single dataframe.
## so end up with a dataframe of ref-neigh cell type Z scores for each circle size, all for a given distance tested
circsize_results <- meltResultsList(resultsList = results_circsize150, id = "150")

# plotTrends(results = circsize_results, figPath = figpath,
#            width = 8, height = 8)
  

## melt the list of combined dataframes and add a new column indicating the list name, aka the distance param that was used for each one.
pos_1circle_results_melt <- purrr::map_df(pos_1circle_results, ~as.data.frame(.x), .id="dist")
colnames(pos_1circle_results_melt) <- c("dist", "resolution", "neighbor", "Z", "reference", "ring_size")
head(pos_1circle_results_melt)
dim(pos_1circle_results_melt)
```

## visualize

trend plots are basically a set of panels, where each panel is a reference vs neighbor cell type.
Each trend is the Z significance score (y-axis) vs resolution (x-axis)
For a given panel, there can be multiple trend lines, each corresponding to an additional parameter.
For example, for a given circle size simulation, we can plot a trend line for each distance tested
In this case, we will need to generate a separate trend plot for each circle size simulation


```{r}
plotTrends(results = results, idcol = "dist", figPath = 'test.pdf',
            width = 12, height = 12)
```


```{r}
figpath <- "../plots/"
## can generate a trend plot for each distance tested, and 
distances <- as.character(distances)
circles <- c("90")
for(c in circles){
# for(d in distances){
  
  figPath <- paste0(figpath, "sim_circles_size", c, "_", "distances.pdf")
  results <- pos_1circle_results_melt[ pos_1circle_results_melt$ring_size == c,]
  
  plotTrends(results = results, idcol = "dist", figPath = 'test.pdf',
            width = 12, height = 12)
  
}
```

```{r}
results <- circsize_results
ggplot2::ggplot(data = results) + 
    ggplot2::geom_line(ggplot2::aes(x=resolution, y=Z, color=neighbor)) + 
    ggplot2::facet_grid(rows = ggplot2::vars(reference))
```

