# ---
title: "Simulation"
output: rmarkdown::html_vignette
vignette: >
  %\VignetteIndexEntry{circle_simulation}
  %\VignetteEngine{knitr::rmarkdown}
  %\VignetteEncoding{UTF-8}
---

```{r, include = FALSE}
knitr::opts_chunk$set(
  collapse = TRUE,
  comment = "#>"
)
```

```{r setup}
library(msctcla)
```

# Simulation

This vignette shows how to use our package to identify cell-type co-localization patterns. In this case, we use simulated circular pattern as the data.

## Simulate the data

We will make a single circle, but you can make several different simulations by changing the number of circles, the size of the ring and the inner core. First, we simulate the background.

```{r}
## background parameters
scale <- 1000 # can be interpreted as microns
size <- 1000 # number of cells
cell_type_background <- c("A")
probability_background <- c(1)

## create background
background_data <- simulate_background(size = size, 
                                       cts = cell_type_background, 
                                       prob = probability_background,
                                       scale = scale)
```

Then, we create the circle patter in this background.

```{r}
## circle parameters
circle_centers <- list(c(500, 500)) # on the chosen scale
cell_types <- list(list(outer = "B", inner = c("C")))
probabilities <- list(list(outer = c(1), inner = c(1)))

## inner circle of 100 microns and outer of 150 microns
radii <- list(list(outer = 150, inner = 100))

## create simulated data with pattern
simulated_data <- simulate_circles(background_data,
                                      circle_centers, 
                                      radii, 
                                      cell_types, 
                                      probabilities)
```

Visualize the data.

```{r}
ggplot2::ggplot(data = simulated_data) +
  ggplot2::geom_point(ggplot2::aes(x = x, y = y, color = type)) +
  ggplot2::scale_color_discrete() 
```

# Find trends

To find the trends, we need a data frame with the (x, y) position of each cell and its cell type. If you are working with real data, you just need to organize it in the same format as the simulated_data variable and apply the following functions.

## Compute trends

```{r}
## parameters fir computing trends
neighbor_distance <- 100 # each distance to define neighbors
resolutions <- c(50, 100, 200, 300) # different shuffling resolutions
permutations <- 1 # number of permutations for shuffling;
seed <- 1
n_cores <- 7 
positions <- simulated_data

results <- findTrends(pos = positions[,c("x", "y")],
                                   celltypes = positions$type,
                                   resolutions,
                                   dist = neighbor_distance,
                                   perms = permutations,
                                   ncores = n_cores,
                                   verbose = TRUE,
                                   saveShuffleFile = 'test.rds',
                                   seed = seed)

## process data
df_results <- meltResultsList(resultsList = results)
```

## Visualize

Here we create a set of panels, where each panel is a reference vs neighbor cell type.
Each trend is the Z significance score (y-axis) vs resolution (x-axis).
For a given panel, there can be multiple trend lines, each corresponding to an additional parameter.

```{r}
plotTrends(results = df_results, figPath = 'test.pdf',
            width = 12, height = 12)
```
