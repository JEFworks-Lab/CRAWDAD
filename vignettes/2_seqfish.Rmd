---
title: "2_seqfish"
author: "Brendan F. Miller"
date: "2/15/2023"
output: html_document
---

```{r}

repoPath <- "/Users/brendan/Desktop/PostDoc/work/HuBMAP/repos/multiscale_celltype_colocalization_analysis/"

```

```{r}

library(parallel)
library(sf)
library(sp)
library(ggplot2)
library(assertthat)
library(reshape2)
library(MASS)
library(stats)
library(dplyr)

source(paste0(repoPath, "R/functions.R"))

```

note that this data was taken from squidpy, and the coordinates were originally:
min(x) = -2.5493682364864583
max(x) = 2.520293708124292
min(y) = -3.4920842294172303
max(y) = 3.4920842294172374

transformed (in python) to bring coordinates in range of approx 1-4000
df['x'] = df['x'] + abs(df.x.min())
df['y'] = df['y'] + abs(df.y.min())
df['x'] = df['x'] * 1000
df['y'] = df['y'] * 1000

# visualize clusters

```{r}

path_to_seqfish <- paste0(repoPath, "data/seqfish/seqfish.meta.csv.gz")

meta <- read.csv2(file = path_to_seqfish, row.names = 1, sep=',')
meta <- meta[,c("x", "y", "cluster")]
## make sure the coordinates are numeric
meta <- meta %>% 
  dplyr::mutate_at(vars(x, y), as.numeric)

head(meta)

```

```{r, fig.height=24, fig.width=24}

vizEachCluster(object = meta[,c("x", "y")], clusters = as.factor(meta$cluster), s = 2)

```

# find pairwise trends

input files and parameters for `findTrends()`

```{r}

## full path to the shuffled data rds
## if it exists, it will be loaded into the function, if not, will be created and saved at this location
shuffledDataPath <- paste0(repoPath, "data/seqfish/sp.seqfish.shuffled_res100-6000.rds")
outfile <- paste0(repoPath, "data/seqfish/sp.seqfish.pairwise.50-300.results.res100-6000.removeDups.rds")

## number of cores
ncs <- 7 

## number of permutations
prms <- 1 

## seed
sd <- 1 

## don't count neighbor cells more than once
removedups <- TRUE

## for pairwise, can assess as several different neighbor distances, which will be combined at the end
distances <- c(50,100,200,300)
## shuffling resolutions
resolutions <- c(100, 200, 300, 400, 500, 600, 700, 800, 900, 1000, 1200, 1500, 3000, 6000)

## the `pos` data.frame, but these lines load it back in properly
meta <- read.csv2(file = path_to_seqfish, row.names = 1, sep=',')
meta <- meta[,c("x", "y", "cluster")]
## make sure the coordinates are numeric
meta <- meta %>% 
  dplyr::mutate_at(vars(x, y), as.numeric)

head(meta)

```

```{r}

pairwise_results <- lapply(distances, function(d){
  
  if(file.exists(shuffledDataPath)){
    
    results <- findTrendsv2(pos = meta[,c("x", "y")],
                             celltypes = meta[,3],
                             resolutions,
                             dist = d,
                             sub.type = "pairwise",
                             perms = prms,
                             ncores = ncs,
                             verbose = TRUE,
                             loadShuffleFile = shuffledDataPath,
                             seed = sd,
                             removeDups = removedups)
  } else {
    results <- findTrendsv2(pos = meta[,c("x", "y")],
                             celltypes = meta[,3],
                             resolutions,
                             dist = d,
                             sub.type = "pairwise",
                             perms = prms,
                             ncores = ncs,
                             verbose = TRUE,
                             saveShuffleFilePath = shuffledDataPath,
                             seed = sd,
                             removeDups = removedups)
  }
  # print(results)
  return(results)
  
})

names(pairwise_results) <- distances

saveRDS(object = pairwise_results, file = outfile)

```

notes when running on RockFish cluster:
1 node
14 CPUs
8G per CPU

100 micron resolution
3570 tiles to shuffle...
shuffling permutation 1 using seed 1
200 micron resolution
910 tiles to shuffle...
shuffling permutation 1 using seed 1
300 micron resolution
408 tiles to shuffle...
shuffling permutation 1 using seed 1
400 micron resolution
234 tiles to shuffle...
shuffling permutation 1 using seed 1
500 micron resolution
154 tiles to shuffle...
shuffling permutation 1 using seed 1
600 micron resolution
108 tiles to shuffle...
shuffling permutation 1 using seed 1
700 micron resolution
80 tiles to shuffle...
shuffling permutation 1 using seed 1
800 micron resolution
63 tiles to shuffle...
shuffling permutation 1 using seed 1
900 micron resolution
48 tiles to shuffle...
shuffling permutation 1 using seed 1
1000 micron resolution
42 tiles to shuffle...
shuffling permutation 1 using seed 1
1200 micron resolution
30 tiles to shuffle...
shuffling permutation 1 using seed 1
1500 micron resolution
20 tiles to shuffle...
shuffling permutation 1 using seed 1
3000 micron resolution
6 tiles to shuffle...
shuffling permutation 1 using seed 1
6000 micron resolution
2 tiles to shuffle...
shuffling permutation 1 using seed 1

note that for some resolutions the same number of tiles are made

dist=300 was about 2.27 min, not bad for pairwise



seff:
Nodes: 1
Cores per node: 14
CPU Utilized: 00:37:45
CPU Efficiency: 57.57% of 01:05:34 core-walltime
Job Wall-clock time: 00:04:41
Memory Utilized: 11.46 GB
Memory Efficiency: 10.23% of 112.00 GB

about 12Gb memory, 14 cores, 5 min runtime for 50,100,200,300 distances


## visualize

```{r}

figPath <- paste0(repoPath, "plots/seqfish/")

```

```{r}

dat <- readRDS(outfile)

dat <- meltResultsList(resultsList = dat, id = NA)
colnames(dat) <- c("resolution", "neighbor", "Z", "reference", "dist", "id")

head(dat)

```

```{r}

## visualize the trends with neighbor distance of 100
d <- dat[dat$dist == "100",]
plotTrends(results = d, idcol = "dist", legend = FALSE,
           figPath = paste0(figPath, "sp.seqfish.pairwise.d100.trends.pdf"),
           width = 50, height = 50)

```

note: cardiomyocytes with either NMP or Presomitic mesoderm neighbors are NAs
(actually at 6000 there are values but NA at finer resolutions. Maybe because the cell types are so separated?)

# find subset trends

## define the cell type subsets

input files and parameters for `getSubsets()`

```{r}

## full path to the subset dataset list rds
subsetDataPath <- paste0(repoPath, "data/seqfish/sp.seqfish.subsets.near.subdist100.rds")

## test if a cell is "near" or "away" a given cell type
## by testing if it's neighbors are significantly enriched or depleted in a cell type via binomial test
subsetType <- "near"

## distance to define subsets; ie the distance to define neighbors for this test
subdist <- 100


## for "away", loosely test for enrichment, then take the cells that still fail this test
## so assume that they must be highly depleted
if(subsetType == "near"){
  subThresh <- 0.05
} else if(subsetType == "away"){
  subThresh <- 0.5
} else (
  stop("subsetType must be either 'near' or 'away'")
)

## number of cores
ncs <- 7 

## the `pos` data.frame, but these lines load it back in properly
meta <- read.csv2(file = path_to_seqfish, row.names = 1, sep=',')
meta <- meta[,c("x", "y", "cluster")]
## make sure the coordinates are numeric
meta <- meta %>% 
  dplyr::mutate_at(vars(x, y), as.numeric)


## create the spatial dataframe:
pos <- meta[,c("x", "y")]
celltypes <- meta[,3]

if(length(levels(celltypes)) == 0){
  message("Warning: `celltypes` does not have levels. Creating levels from values")
  celltypes <- factor(celltypes)
  names(celltypes) <- rownames(pos)
}

cells <- sp::SpatialPointsDataFrame(
    coords = as.data.frame(pos),
    data = data.frame(
        celltypes = celltypes
        #name=rownames(pos)
))
cells <- sf::st_as_sf(cells)

## Change rowname assignments of cells to integers.
## Solution to keep rows in same order later on when
## randomly shuffling cell labels
rownames(cells) <- as.character(1:dim(cells)[1])

# make assumption that cell type attribute is constant throughout the geometries of each cell
## it removed the warning that keep popping up, which says this assumption is made anyways
sf::st_agr(cells) <- "constant"

```

```{r}

## if subset data exists, set up parameters to load it in, otherwise set them up to save it once made
if(file.exists(subsetDataPath)){
  loadSubset <- subsetDataPath
  saveSubset <- NA
} else {
  loadSubset <- NA
  saveSubset <- subsetDataPath
}

if(assertthat::is.string(loadSubset)){
    subset.list <- readRDS(file = loadSubset)
} else {
    
    ## parallel shuffling of the grids in each resolution
    subset.list <- getSubsets(cells = cells,
                            sub.dist = subdist,
                            sub.type = subsetType,
                            sub.thresh = subThresh,
                            ncores = ncs,
                            verbose = TRUE,
                            removeDups = FALSE)
    if(assertthat::is.string(saveSubset)){
        saveRDS(object = subset.list, file = saveSubset)
    }
}

```

notes from RockFish:
Identifying subsets of cells that are near a given neighbor cell type based on distance of 100

for subset neighbor distance of 100, took about 21 minutes

longest combination:
computing subsets for Forebrain/Midbrain/Hindbrain_near_Splanchnic mesoderm
Time to compute was 0.17mins

seff:
Nodes: 1
Cores per node: 32
CPU Utilized: 07:59:51
CPU Efficiency: 71.41% of 11:12:00 core-walltime
Job Wall-clock time: 00:21:00
Memory Utilized: 7.37 GB
Memory Efficiency: 11.51% of 64.00 GB

Memory not too bad

about 19.5K cells in this dataset
22 cell types, so 484 subset combos

## visualize subsets

for selecting specific cells for plotting

```{r}

getSubsetComs <- function(com, pos, subset_list, subsetIDs, neighIDs){
  
  ## get vector to append cell annotations of interest
  annots_temp <- rep(NA, length(rownames(pos)))
  names(annots_temp) <- rownames(pos)
  
  ## append the neighbor cells
  if(!is.na(neighIDs[1])){
    for(neigh_id in neighIDs){
      annots_temp[com == neigh_id] <- neigh_id
    }
  }
  
  ## get cell ids that are part of subset
  ## these added after the neigbors in case
  ## you want to plot all CD4 T cells first
  # then color the ones that are a subset
  ## note that the order will be important
  ## because labels are overwritten in this way
  if(!is.na(subsetIDs[1])){
    for(subsetID in subsetIDs){
      cells_temp <- as.numeric(subset_list[[subsetID]])
      ## append the subset label
      annots_temp[cells_temp] <- subsetID
    }
  }
  
  annots_temp <- as.factor(annots_temp)
  return(annots_temp)
}

```

```{r}

subsets <- readRDS(subsetDataPath)

id <- "subset dist 100"
pos <- meta[,c("x", "y")]
com <- as.factor(meta$cluster)
names(com) <- rownames(pos)


# ----------------------------------------

annots_temp <- getSubsetComs(com = com,
                             pos = pos,
                             subset_list = subsets,
                             neighIDs = c("Lateral plate mesoderm", "Allantois", "Intermediate mesoderm"),
                             subsetIDs = NA)
plt <- vizAllClusters(object = pos,
               clusters = annots_temp,
               title = id,
               axisAdj = 1, s = 4, a = 0.5) +
  ggplot2::guides(colour = ggplot2::guide_legend(override.aes = list(size=2), ncol = 1)) +
  # ggplot2::theme(legend.position="none") +
  ggplot2::labs(x = "x",
                y = "y")
plt

# ggplot2::ggsave(filename ="sim_circSubset.v2.AnearB.pdf",
#                 path = figpath, device = "pdf",
#                 plot = plt,
#                 dpi = 600, width = 4, height = 3, units = "in")

```

## subset trends

note that we can reuse the same shuffled dataset that was made in the pairwise analysis

```{r}

## full path to the shuffled data rds
## if it exists, it will be loaded into the function, if not, will be created and saved at this location
shuffledDataPath <- paste0(repoPath, "data/seqfish/sp.seqfish.shuffled_res100-6000.rds")
outfile_subsets_triplet <- paste0(repoPath, "data/seqfish/sp.seqfish.triplet.near.binom.subdist100.dist100.results.res100-6000.removeDups.rds")


## full path to the subset dataset list rds
subsetDataPath <- paste0(repoPath, "data/seqfish/sp.seqfish.subsets.near.subdist100.rds")

## test if a cell is "near" or "away" a given cell type
## by testing if it's neighbors are significantly enriched or depleted in a cell type via binomial test
subsetType <- "near"

## distance to define subsets; ie the distance to define neighbors for this test
subdist <- 100


## for "away", loosely test for enrichment, then take the cells that still fail this test
## so assume that they must be highly depleted
if(subsetType == "near"){
  subThresh <- 0.05
} else if(subsetType == "away"){
  subThresh <- 0.5
} else (
  stop("subsetType must be either 'near' or 'away'")
)


## number of cores
ncs <- 7 

## number of permutations
prms <- 1 

## seed
sd <- 1 

## don't count neighbor cells more than once
removedups <- TRUE

## for subset, use one neighbor distance
distances <- c(100)
## shuffling resolutions
resolutions <- c(100, 200, 300, 400, 500, 600, 700, 800, 900, 1000, 1200, 1500, 3000, 6000)

## the `pos` data.frame, but these lines load it back in properly
meta <- read.csv2(file = path_to_seqfish, row.names = 1, sep=',')
meta <- meta[,c("x", "y", "cluster")]
## make sure the coordinates are numeric
meta <- meta %>% 
  dplyr::mutate_at(vars(x, y), as.numeric)

head(meta)

```

```{r}

## if subset data exists, set up parameters to load it in, otherwise set them up to save it once made
if(file.exists(subsetDataPath)){
  loadSubset <- subsetDataPath
  saveSubset <- NA
} else {
  loadSubset <- NA
  saveSubset <- subsetDataPath
}

triplet_results <- lapply(distances, function(d){
  
  if(file.exists(shuffledDataPath)){
    
    results <- findTrendsv2(pos = meta[,c("x", "y")],
                             celltypes = meta[,3],
                             resolutions,
                             dist = d,
                             sub.dist = subdist,
                             sub.type = subsetType,
                             sub.thresh = subThresh,
                             perms = prms,
                             ncores = ncs,
                             verbose = TRUE,
                             loadShuffleFile = shuffledDataPath,
                             loadSubsetFile = loadSubset,
                             saveSubsetFile = saveSubset,
                             seed = sd,
                             removeDups = removedups)
  } else {
    results <- findTrendsv2(pos = meta[,c("x", "y")],
                             celltypes = meta[,3],
                             resolutions,
                             dist = d,
                             sub.dist = subdist,
                             sub.type = subsetType,
                             sub.thresh = subThresh,
                             perms = prms,
                             ncores = ncs,
                             verbose = TRUE,
                             saveShuffleFilePath = shuffledDataPath,
                             loadSubsetFile = loadSubset,
                             saveSubsetFile = saveSubset,
                             seed = sd,
                             removeDups = removedups)
  }
  return(results)
  
})

names(triplet_results) <- distances

saveRDS(object = triplet_results, file = outfile_subsets_triplet)

```

notes when running on RockFish cluster:
1 node
14 CPUs
8G per CPU (overkill for this)


seff:
Nodes: 1
Cores per node: 14
CPU Utilized: 00:38:50
CPU Efficiency: 35.64% of 01:48:58 core-walltime
Job Wall-clock time: 00:07:47
Memory Utilized: 4.07 GB
Memory Efficiency: 3.63% of 112.00 GB

using neighbor distance of 100
Calculating for subset type: near
within subset distance of: 100

Time was 7.53 mins

not bad, actually for subsets

## visualize subset trends

```{r}

figPath <- paste0(repoPath, "plots/seqfish/")

```

```{r}

dat <- readRDS(outfile_subsets_triplet)

dat <- meltResultsList(resultsList = dat, id = NA)
colnames(dat) <- c("resolution", "neighbor", "Z", "reference", "dist", "subdist")

dat$subdist = "100"

head(dat)

```

```{r}

## visualize the trends with neighbor distance of 100
d <- dat[dat$dist == "100",]
plotTrends(results = d, idcol = "dist", legend = FALSE,
           figPath = paste0(figPath, "sp.seqfish.triplet.d100.sd100.trends.pdf"),
           width = 20, height = 8)

```







