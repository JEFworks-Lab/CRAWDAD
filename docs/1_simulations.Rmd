---
title: "1_simulations"
author: "Brendan F. Miller"
date: "2/15/2023"
output: html_document
---

```{r}

library(crawdad)
library(dplyr)

```

```{r}

ncores = 7

```

```{r}

## folder on `brendan` branch
figpath <- paste0(here::here(), "/plots/sim")

```

## Make simulated dataset

```{r}

## cells
set.seed(1)
size <- 8000
x <- runif(size, min = 0, max = 2000)
y <- runif(size, min = 0, max = 2000)
p <- data.frame(x = x, y = y, type='D')
rownames(p) <- paste0('cell', 1:size)

## structures

## large A circles
as <- c(250, 250, 750, 750)*2
bs <- c(250, 750, 250, 750)*2
invisible(sapply(1:4, function(i) {
  a <- as[i]
  b <- bs[i]
  ro <- 150*2
  co <- 'A'
  po <- 1
  c1o <- rownames(p[((p$x-a)^2 + (p$y - b)^2 < ro^2),])
  p[c1o,]$type <<- sample(co, size = length(c1o), replace = TRUE, prob = po)
}))

## B blobs inside A blobs
invisible(sapply(1:4, function(i) {
  ro <- 50*2 # 80
  # co <- 'B'
  co <- c('B', 'C')
  # po <- 1
  po <- c(0.5, 0.5)
  
  ## inside structure
  a <- as[i]
  b <- bs[i]
  c1o <- rownames(p[((p$x-a)^2 + (p$y - b)^2 < ro^2),])
  p[c1o,]$type <<- sample(co, size = length(c1o), replace = TRUE, prob = po)
}))

# ## add some small B blobs elsewhere
# as2 <- c(100, 100, 900, 900)
# bs2 <- c(100, 900, 100, 900)
# invisible(sapply(1:4, function(i) {
#   ro <- 50
#   co <- 'B'
#   po <- 1
#   ## outside structure
#   a <- as2[i]
#   b <- bs2[i]
#   c1o <- rownames(p[((p$x-a)^2 + (p$y - b)^2 < ro^2),])
#   p[c1o,]$type <<- sample(co, size = length(c1o), replace = TRUE, prob = po)
# }))

# ## add smaller C blobs in the B blobs in the A blobs
# invisible(sapply(1:4, function(i) {
#   ro <- 40
#   co <- 'C'
#   po <- 1
#   
#   ## inside structure
#   a <- as[i]
#   b <- bs[i]
#   c1o <- rownames(p[((p$x-a)^2 + (p$y - b)^2 < ro^2),])
#   p[c1o,]$type <<- sample(co, size = length(c1o), replace = TRUE, prob = po)
# }))

# ## add some small C blobs elsewhere
# as3 <- c(100, 500, 500, 900)
# bs3 <- c(500, 100, 900, 500)
# invisible(sapply(1:4, function(i) {
#   ro <- 50
#   co <- 'C'
#   po <- 1
#   ## outside structure
#   a <- as3[i]
#   b <- bs3[i]
#   c1o <- rownames(p[((p$x-a)^2 + (p$y - b)^2 < ro^2),])
#   p[c1o,]$type <<- sample(co, size = length(c1o), replace = TRUE, prob = po)
# }))

## visualize
plt <- crawdad::vizAllClusters(cells = p,
                               coms = p$type,
                               title = "sim",
                               axisAdj = 1, s = 6, a = 0.5) +
  ggplot2::guides(colour = ggplot2::guide_legend(override.aes = list(size=2), ncol = 1))
plt

ggplot2::ggsave(filename = "1A_sim_tissue_legend.pdf",
                plot = plt,
                device = "pdf",
                path = figpath,
                scale = 1,
                width = 6,
                height = 6,
                units = c("in"))

```

Convert the data.frame of cells to an `sp::SpatialPointsDataFrame` object. This is because CRAWDAD builds upon the `sf` library in R.

```{r}

## convert to SP
cells <- crawdad:::toSP(pos = p[,c("x", "y")],
                        celltypes = p$type)
cells

```

## Make shuffled background

`CRAWDAD` identifies cell type spatial relationships by comparing cell type organizational patterns in the real data to a set of null distributions, which are a datasets in which cell labels have been shuffled at different scales, or resolutions. We can generate this list of shuffled datasets with the following code:

```{r}
## generate background
shuffle.list <- crawdad:::makeShuffledCells(cells,
                          resolutions = c(150, 250, 500, 750, 1000, 1500, 2000),
                          perms = 1,
                          ncores = ncores,
                          seed = 1,
                          verbose = TRUE)
```

## Run pairwise analysis

We can identify trends that describe spatial relationships between pairwise combinations of cell types in our data. `dist` refers to the distance at which neighbor cells are defined. In this example, we assess if the neighbors of each cell type are enriched or depleted in cells of another given cell type compared to each shuffled resolution of the data.

```{r}

## find trends, passing background as parameter
results <- crawdad::findTrends(cells,
                        dist = 100,
                        shuffle.list = shuffle.list,
                        ncores = ncores,
                        verbose = TRUE)

```

```{r}

dat <- crawdad::meltResultsList(results)

plt <- ggplot2::ggplot(dat, ggplot2::aes(x=resolution, y=Z, col=neighbor)) +
  ggplot2::geom_line() +
  ggplot2::facet_grid(rows = ggplot2::vars(reference)) +
  ggplot2::theme_classic() +
  ggplot2::geom_hline(yintercept = 2, col='lightgrey' ,linetype="dotted") + 
  ggplot2::geom_hline(yintercept = -2, col='lightgrey',linetype="dotted") +
  ggplot2::scale_x_continuous(trans='log10', breaks = c(150, 250, 500, 1000, 2000)) +
  
  ggplot2::theme(axis.text.x = ggplot2::element_text(size=12, color = "black", angle = -90, vjust = 0.5, hjust = 0),
                   # axis.text.y = ggplot2::element_text(size=12, color = "black"),
                   # axis.title.y = ggplot2::element_text(size=15),
                   # axis.title.x = ggplot2::element_text(size=15),
                   # axis.ticks.x = ggplot2::element_blank(),
                   # plot.title = ggplot2::element_text(size=15),
                   plot.background = ggplot2::element_blank(),
                   legend.background = ggplot2::element_blank(),
                   panel.background = ggplot2::element_blank()
                   # panel.grid.major =  ggplot2::element_line(size = 0.1, colour = "black"),
                   # panel.border = ggplot2::element_rect(colour = "black", fill=NA, size=1),
                   # axis.line = ggplot2::element_line(size = 0, colour = "black"),
                   # panel.spacing = ggplot2::unit(0.1, "lines"),
                   # strip.text = ggplot2::element_text(size = 12),
                   # legend.title = ggplot2::element_blank(),
                   # legend.position="none"
    )
plt

ggplot2::ggsave(filename = "1B_sim_tissue_trends.pdf",
                plot = plt,
                device = "pdf",
                path = figpath,
                scale = 1,
                width = 8,
                height = 6,
                units = c("in"))

```


# ==========================
# OLD

```{r}

repoPath <- "/Users/brendan/Desktop/PostDoc/work/HuBMAP/repos/multiscale_celltype_colocalization_analysis/"

```

```{r}

figPath <- paste0(repoPath, "plots/sim/")

```

```{r}

library(parallel)
library(sf)
library(sp)
library(ggplot2)
library(assertthat)
library(reshape2)
library(MASS)
library(stats)
library(dplyr)

source(paste0(repoPath, "R/functions.R"))

```

## pairwise simulation

```{r}

## initialize circle params

locs <- list(
  c(0.5, 0.5)
  )

cts <- list(
  list(outer = "B", inner = c("C"))
  )

probs <- list(
  list(outer = c(1), inner = c(1))
  )

## background params
s <- 5000
cb <- c("A")
pb <- c(1)

## outer ring approx 0.10 or 3100um = 310 micron width
## inner approx 310 microns across (3100*0.10)
rads <- replicate(1, list(outer = 0.15, inner = 0.05), simplify=FALSE)


pos <- simulate_circles(simulate_background(size = s, cts = cb, prob = pb),
                        locs, radii = rads, cts, probs)


pos$x <- pos$x * 3100
pos$y <- pos$y * 3100

plt <- vizAllClusters(object = pos[,c("x", "y")],
              clusters = pos[,c("type")], s = 3)

plt

ggplot2::ggsave(plot = plt,
                filename = paste0(figPath, "sim.pairwise.circle.png"),
                device = "png",
                dpi = 300,
                scale = 1,
                width = 6,
                height = 6,
                units = c("in")
                )


resolutions <- c(100, 200, 300, 400, 500, 600, 700, 800, 900, 1000, 1200, 1500, 3000, 6000)

```

# subset simulation

```{r}

## initialize circle params

## one circle; but set up for two rings
## so have two circles with same center
## make first circle the largest
## then place the second smaller circle in the center

locs <- list(
  c(0.5, 0.5),
  c(0.5, 0.5)
  )

cts <- list(
  list(outer = c("C"), inner = c("C")),
  list(outer = c("A"), inner = c("B"))
  )

probs <- list(
  list(outer = c(1), inner = c(1)),
  list(outer = c(1), inner = c(1))
  )

replacement <- list(
  list(outer = TRUE, inner = TRUE),
  list(outer = TRUE, inner = TRUE)
  )

rads <- list(
  list(outer = c(0.14), inner = c(0.10)),
  list(outer = c(0.10), inner = c(0.08))
)

## background params
s <- 5000
cb <- c("A", "B", "C")
pb <- c(0.36, 0.30, 0.34)

pos_subset <- simulate_circles(pos = simulate_background(size = s, cts = cb, prob = pb),
                        locs = locs, radii = rads, cts = cts, probs = probs)


pos_subset$x <- pos_subset$x * 3100
pos_subset$y <- pos_subset$y * 3100

plt <- vizAllClusters(object = pos_subset[,c("x", "y")],
                      clusters = pos_subset[,c("type")], s = 3)

plt

ggplot2::ggsave(plot = plt,
                filename = paste0(figPath, "sim.subset.circle.png"),
                device = "png",
                dpi = 300,
                scale = 1,
                width = 6,
                height = 6,
                units = c("in")
                )

resolutions <- c(100, 200, 300, 400, 500, 600, 700, 800, 900, 1000, 1200, 1500, 3000, 6000)
sub.dist <- 300
neigh.dist <- 100

```

